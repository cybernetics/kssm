<HTML>
<HEAD>
<meta charset="UTF-8">
<title>StateMachine.setStrictStateMatching - kssm</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">kssm</a>&nbsp;/&nbsp;<a href="../index.html">me.angrybyte.kssm.api</a>&nbsp;/&nbsp;<a href="index.html">StateMachine</a>&nbsp;/&nbsp;<a href="./set-strict-state-matching.html">setStrictStateMatching</a><br/>
<br/>
<h1>setStrictStateMatching</h1>
<a name="me.angrybyte.kssm.api.StateMachine$setStrictStateMatching(kotlin.Boolean)"></a>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">setStrictStateMatching</span><span class="symbol">(</span><span class="identifier" id="me.angrybyte.kssm.api.StateMachine$setStrictStateMatching(kotlin.Boolean)/strict">strict</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Allows the caller to switch between <strong>strict</strong> and <strong>loose</strong> state matching modes. When transitioning using an
action, the state machine will try to find the resulting state by looking for the current state and the given
action.</p>
<p>Default value is <code>true</code> (strict mode).</p>
<h3>Strict matching</h3>
<p>With <strong>strict</strong> matching, current state and the new action will be compared using <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html">Any.equals</a>, which means that
state/action type, name and payload all must match their stored mappings. An example:</p>
<pre><code class="lang-kotlin">object AB : SingletonAction()
object A : SingletonState()
object B : SingletonState()

val sm = stateMachine {
  mappings(AB moves A to B)
  initialState = A
}

// fails and reports an error (mismatch: payload and state type)
sm.transition(namedState("AB"))
</code></pre>
<h3>Loose matching</h3>
<p>In contrast to strict state matching, <strong>loose</strong> matching will allow you to process actions during the transition
phase even though the payload or action/state type are different from the ones in the mapping list. The only thing
compared will be the <code>name</code> property of the action/state. An example:</p>
<pre><code class="lang-kotlin">object AB : SingletonAction()
object A : SingletonState()
object B : SingletonState()

val sm = stateMachine {
  mappings(AB moves A to B)
  initialState = A
}

sm.transition(namedState("AB"))
println(sm.currentState) // B, because only 'AB' name is being matched
</code></pre>
<h3>Use-cases</h3>
<p>Loose matching is extremely useful if you want to send a different payload with the same action name, for example.
Another use-case would be using an internally-mutable payload in a state - that would not match the initial
payload provided in the state mapping block.</p>
<h3>Exceptions</h3>
<p><a name="IncubationPassedException"></a>
<code>IncubationPassedException</code> - if state machine has already started processing events</p>
</BODY>
</HTML>
